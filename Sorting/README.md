
# 정렬(Sorting)

## 선택 정렬 *Selection Sort*
가장 원시적인 방법, 가장 작은 것을 선택
1. 전체 중 가장 작은 데이터를 선택, 맨 앞 데이터와 교환
2. 정렬되지 않은 데이터 중 가장 작은 데이터를 선택, 정렬되지 않은 데이터 중 맨 앞 데이터와 교환
3. 데이터가 n개이면 n-1번 반복 (마지막 데이터는 가만히 두어도 이미 정렬된 상태)

시간복잡도 O(N^2)

## 삽입 정렬 *Insertion Sort*
특정한 데이터를 삽입

**데이터가 거의 정렬되어 있을 때 효율적**

첫 데이터는 정렬되어 있다고 판단, 두 번째 데이터부터 시작한다.
1. 두 번째 데이터와 첫 번째 데이터를 비교해 어떤 위치로 들어갈 지 판단하고 삽입한다.
2. 정렬되지 않은 데이터 중 맨 앞 데이터를 정렬된 데이터의 어느 위치에 들어갈지 판단하고 삽입한다.
3. 마지막까지 반복

삽입 시 해당 데이터를 한 칸씩 왼쪽으로 이동하고 자신보다 작은 수를 만나면 멈추면 된다.
시간복잡도 O(N^2)
최선의 경우 O(N) - 거의 정렬되어 있는 경우 

## 퀵 정렬 *Quick Sort*
가장 많이 사용되는 알고리즘 (여기서는 가장 대표적인 호어 분할*Hoare Partition*을 사용)

1. 리스트에서 첫 번째 데이터를 피벗*Pivot*으로 정한다. 
2. 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 
3. 서로 엇갈린 경우 작은 데이터와 피벗의 위치를 변경, 엇갈리지 않은 경우 두 데이터의 위치를 변경
4. 1~3을 반복

재귀함수로 구현하되 끝나는 조건은 현재 리스트의 데이터 개수가 1개인 경우이다. 
시간복잡도 평균:O(NlogN) 최악:O(N^2)
데이터가 무작위로 입력되는 경우 빠르게 동작하지만 이미 데이터가 정렬되어 있는 경우(가장 왼쪽 데이터를 피벗으로 삼을 때) 매우 느리게 동작한다.

## 계수 정렬 *Count Sort*
특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
데이터의 크기 범위가 제한, 정수 형태로 표현할 수 있을 때 (가장 큰 데이터, 가장 작은 데이터의 차이 < 1,000,000)
1. 데이터의 범위 크기의 리스트를 선언해 데이터를 하나씩 확인하며 값과 동일한 인덱스의 데이터를 1씩 증가한다.
2. 인덱스의 값만큼 인덱스를 출력한다.
시간복잡도: 데이터의 개수가 N, 데이터의 최댓값이 K일 때 최악의 경우에도 O(N+K)
